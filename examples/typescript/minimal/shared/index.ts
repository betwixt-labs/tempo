//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.5.4
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord } from "bebop";
import { Metadata } from "@tempojs/common";
import {  BaseClient, MethodInfo, CallOptions } from "@tempojs/client";
import { ServiceRegistry, BaseService, ServerContext, BebopMethodAny, BebopMethod } from "@tempojs/server";

/**
 * `HelloRequest` is a struct representing a request to the Greeter service.
 */
export interface IHelloRequest extends BebopRecord {
  /**
   * The name to be used in the greeting, of type string.
   */
  name: string;
}

export class HelloRequest implements IHelloRequest {
  public name: string;

  constructor(record: IHelloRequest) {
    this.name = record.name;
  }

  public encode(): Uint8Array {
    return HelloRequest.encode(this);
  }

  public static encode(record: IHelloRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloRequest, view: BebopView): number {
    const before = view.length;
    view.writeString(record.name);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloRequest {
    let field0: string;
    field0 = view.readString();
    let message: IHelloRequest = {
      name: field0,
    };
    return new this(message);
  }
}

/**
 * `HelloResponse` is a struct representing the response from the Greeter service.
 */
export interface IHelloResponse extends BebopRecord {
  /**
   * The greeting message generated by the service, of type string.
   */
  serviceMessage: string;
}

export class HelloResponse implements IHelloResponse {
  public serviceMessage: string;

  constructor(record: IHelloResponse) {
    this.serviceMessage = record.serviceMessage;
  }

  public encode(): Uint8Array {
    return HelloResponse.encode(this);
  }

  public static encode(record: IHelloResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloResponse, view: BebopView): number {
    const before = view.length;
    view.writeString(record.serviceMessage);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloResponse {
    let field0: string;
    field0 = view.readString();
    let message: IHelloResponse = {
      serviceMessage: field0,
    };
    return new this(message);
  }
}

/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
export abstract class BaseGreeterService extends BaseService {
  public static readonly serviceName = 'GreeterService';
  public abstract sayHello(record: IHelloRequest, context: ServerContext): Promise<IHelloResponse>;
}

export class TempoServiceRegistry extends ServiceRegistry {
  private static readonly staticServiceInstances: Map<string, BaseService> = new Map<string, BaseService>();
  public static register(serviceName: string) {
    return (constructor: Function) => {
      const service = Reflect.construct(constructor, [undefined]);
      if (TempoServiceRegistry.staticServiceInstances.has(serviceName)) {
        throw new Error(`Duplicate service registered: ${serviceName}`);
      }
      TempoServiceRegistry.staticServiceInstances.set(serviceName, service);
    }
  }
  public static tryGetService(serviceName: string): BaseService {
    const service = TempoServiceRegistry.staticServiceInstances.get(serviceName);
    if (service === undefined) {
      throw new Error(`Unable to retreive service '${serviceName}' - it is not registered.`);
    }
    return service;
  }

  public init(): void {
    let service: BaseService;
    let serviceName: string;
    serviceName = 'GreeterService';
    service = TempoServiceRegistry.tryGetService(serviceName);
    if (!(service instanceof BaseGreeterService)) {
      throw new Error('todo');
    }
    service.setLogger(this.logger.clone(serviceName));
    TempoServiceRegistry.staticServiceInstances.delete(serviceName);
    this.serviceInstances.push(service);
    if (this.methods.has(1225452181)) {
      const conflictService = this.methods.get(1225452181)!;
      throw new Error(`GreeterService.sayHello collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(1225452181, {
      name: 'sayHello',
      service: serviceName,
      invoke: service.sayHello,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
  }

  getMethod(id: number): BebopMethodAny | undefined {
    return this.methods.get(id);
  }
}
export interface IGreeterClient {
  sayHello(request: IHelloRequest): Promise<IHelloResponse>;
  sayHello(request: IHelloRequest, metadata: Metadata): Promise<IHelloResponse>;
}

export class GreeterClient extends BaseClient implements IGreeterClient {
  private static readonly sayHelloMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHello',
    service: 'GreeterService',
    id: 1225452181,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode
  }
  async sayHello(request: IHelloRequest): Promise<IHelloResponse>;
  async sayHello(request: IHelloRequest, options: CallOptions): Promise<IHelloResponse>;
  async sayHello(request: IHelloRequest, options?: CallOptions): Promise<IHelloResponse> {
    return await this.channel.send(request, this.getContext(), GreeterClient.sayHelloMethodInfo, options);
  }
}
