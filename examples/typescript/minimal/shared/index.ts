//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.0.3-beta.2
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";
import { Metadata, MethodType } from "@tempojs/common";
import {  BaseClient, MethodInfo, CallOptions } from "@tempojs/client";
import { ServiceRegistry, BaseService, ServerContext, BebopMethodAny, BebopMethod } from "@tempojs/server";

export const BEBOP_SCHEMA = new Uint8Array([
3, 2, 0, 0, 0, 72, 101, 108, 108, 111, 82, 101, 113, 117,
101, 115, 116, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 110, 97, 109,
101, 0, 245, 255, 255, 255, 0, 72, 101, 108, 108, 111, 82,
101, 115, 112, 111, 110, 115, 101, 0, 1, 0, 0, 4, 0, 0, 0,
0, 1, 115, 101, 114, 118, 105, 99, 101, 77, 101, 115, 115,
97, 103, 101, 0, 245, 255, 255, 255, 0, 1, 0, 0, 0, 71,
114, 101, 101, 116, 101, 114, 0, 0, 4, 0, 0, 0, 115, 97,
121, 72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
0, 85, 246, 254, 77, 115, 97, 121, 72, 101, 108, 108, 111,
67, 108, 105, 101, 110, 116, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0,
0, 196, 25, 111, 204, 115, 97, 121, 72, 101, 108, 108,
111, 83, 101, 114, 118, 101, 114, 0, 0, 1, 0, 0, 0, 0, 1,
0, 0, 0, 84, 166, 66, 202, 115, 97, 121, 72, 101, 108,
108, 111, 68, 117, 112, 108, 101, 120, 0, 0, 3, 0, 0, 0,
0, 1, 0, 0, 0, 66, 158, 17, 152
]);

/**
 * `HelloRequest` is a struct representing a request to the Greeter service.
 */
export interface IHelloRequest extends BebopRecord {
  /**
   * The name to be used in the greeting, of type string.
   */
  readonly name: string;
}

export class HelloRequest implements IHelloRequest {
  public readonly name: string;

  constructor(record: IHelloRequest) {
    this.name = record.name;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return HelloRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IHelloRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    HelloRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link HelloRequest}.
   */
  public static validateCompatibility(record: IHelloRequest): void {
    BebopTypeGuard.ensureString(record.name)
  }

  /**
   * Unsafely creates an instance of {@link HelloRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IHelloRequest {
      return new HelloRequest(record);
  }

  /**
   * Creates a new {@link HelloRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IHelloRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`HelloRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    HelloRequest.validateCompatibility(parsed);
    return HelloRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return HelloRequest.encode(this);
  }

  public static encode(record: IHelloRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloRequest, view: BebopView): number {
    const before = view.length;
    view.writeString(record.name);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloRequest {
    let field0: string;
    field0 = view.readString();
    let message: IHelloRequest = {
      name: field0,
    };
    return new HelloRequest(message);
  }
}

/**
 * `HelloResponse` is a struct representing the response from the Greeter service.
 */
export interface IHelloResponse extends BebopRecord {
  /**
   * The greeting message generated by the service, of type string.
   */
  readonly serviceMessage: string;
}

export class HelloResponse implements IHelloResponse {
  public readonly serviceMessage: string;

  constructor(record: IHelloResponse) {
    this.serviceMessage = record.serviceMessage;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return HelloResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IHelloResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    HelloResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link HelloResponse}.
   */
  public static validateCompatibility(record: IHelloResponse): void {
    BebopTypeGuard.ensureString(record.serviceMessage)
  }

  /**
   * Unsafely creates an instance of {@link HelloResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IHelloResponse {
      return new HelloResponse(record);
  }

  /**
   * Creates a new {@link HelloResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IHelloResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`HelloResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    HelloResponse.validateCompatibility(parsed);
    return HelloResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return HelloResponse.encode(this);
  }

  public static encode(record: IHelloResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloResponse, view: BebopView): number {
    const before = view.length;
    view.writeString(record.serviceMessage);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloResponse {
    let field0: string;
    field0 = view.readString();
    let message: IHelloResponse = {
      serviceMessage: field0,
    };
    return new HelloResponse(message);
  }
}

/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
export abstract class BaseGreeterService extends BaseService {
  public static readonly serviceName = 'GreeterService';
  /**
   * `sayHello` is a method that takes a `HelloRequest` and returns a `HelloResponse`.
   */
  public abstract sayHello(record: IHelloRequest, context: ServerContext): Promise<IHelloResponse>;
  public abstract sayHelloClient(records: () => AsyncGenerator<IHelloRequest, void, undefined>, context: ServerContext): Promise<IHelloResponse>;
  public abstract sayHelloServer(record: IHelloRequest, context: ServerContext): AsyncGenerator<IHelloResponse, void, undefined>;
  public abstract sayHelloDuplex(records: () => AsyncGenerator<IHelloRequest, void, undefined>, context: ServerContext): AsyncGenerator<IHelloResponse, void, undefined>;
}

export class TempoServiceRegistry extends ServiceRegistry {
  private static readonly staticServiceInstances: Map<string, BaseService> = new Map<string, BaseService>();
  public static register(serviceName: string) {
    return (constructor: Function) => {
      const service = Reflect.construct(constructor, [undefined]);
      if (TempoServiceRegistry.staticServiceInstances.has(serviceName)) {
        throw new Error(`Duplicate service registered: ${serviceName}`);
      }
      TempoServiceRegistry.staticServiceInstances.set(serviceName, service);
    }
  }
  public static tryGetService(serviceName: string): BaseService {
    const service = TempoServiceRegistry.staticServiceInstances.get(serviceName);
    if (service === undefined) {
      throw new Error(`Unable to retreive service '${serviceName}' - it is not registered.`);
    }
    return service;
  }

  public init(): void {
    let service: BaseService;
    let serviceName: string;
    serviceName = 'GreeterService';
    service = TempoServiceRegistry.tryGetService(serviceName);
    if (!(service instanceof BaseGreeterService)) {
      throw new Error(`No service named '${serviceName}'was registered with the TempoServiceRegistry`);
    }
    service.setLogger(this.logger.clone(serviceName));
    TempoServiceRegistry.staticServiceInstances.delete(serviceName);
    this.serviceInstances.push(service);
    if (this.methods.has(1308554837)) {
      const conflictService = this.methods.get(1308554837)!;
      throw new Error(`GreeterService.sayHello collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(1308554837, {
      name: 'sayHello',
      service: serviceName,
      invoke: service.sayHello,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      toJSON: HelloResponse.encodeToJSON,
      fromJSON: HelloRequest.fromJSON,
      type: MethodType.Unary,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(3429833156)) {
      const conflictService = this.methods.get(3429833156)!;
      throw new Error(`GreeterService.sayHelloClient collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(3429833156, {
      name: 'sayHelloClient',
      service: serviceName,
      invoke: service.sayHelloClient,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      toJSON: HelloResponse.encodeToJSON,
      fromJSON: HelloRequest.fromJSON,
      type: MethodType.ClientStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(3393365588)) {
      const conflictService = this.methods.get(3393365588)!;
      throw new Error(`GreeterService.sayHelloServer collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(3393365588, {
      name: 'sayHelloServer',
      service: serviceName,
      invoke: service.sayHelloServer,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      toJSON: HelloResponse.encodeToJSON,
      fromJSON: HelloRequest.fromJSON,
      type: MethodType.ServerStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(2551291458)) {
      const conflictService = this.methods.get(2551291458)!;
      throw new Error(`GreeterService.sayHelloDuplex collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(2551291458, {
      name: 'sayHelloDuplex',
      service: serviceName,
      invoke: service.sayHelloDuplex,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      toJSON: HelloResponse.encodeToJSON,
      fromJSON: HelloRequest.fromJSON,
      type: MethodType.DuplexStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
  }

  getMethod(id: number): BebopMethodAny | undefined {
    return this.methods.get(id);
  }
}
/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
export interface IGreeterClient {
  /**
   * `sayHello` is a method that takes a `HelloRequest` and returns a `HelloResponse`.
   */
  sayHello(request: IHelloRequest): Promise<IHelloResponse>;
  sayHello(request: IHelloRequest, metadata: Metadata): Promise<IHelloResponse>;

  sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<IHelloResponse>;
  sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, metadata: Metadata): Promise<IHelloResponse>;

  sayHelloServer(request: IHelloRequest): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  sayHelloServer(request: IHelloRequest, metadata: Metadata): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;

  sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, metadata: Metadata): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
}

/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
export class GreeterClient extends BaseClient implements IGreeterClient {
  private static readonly sayHelloMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHello',
    service: 'GreeterService',
    id: 1308554837,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    toJSON: HelloRequest.encodeToJSON,
    fromJSON: HelloResponse.fromJSON,
    type: MethodType.Unary,
  }
  /**
   * `sayHello` is a method that takes a `HelloRequest` and returns a `HelloResponse`.
   */
  async sayHello(request: IHelloRequest): Promise<IHelloResponse>;
  async sayHello(request: IHelloRequest, options: CallOptions): Promise<IHelloResponse>;
  async sayHello(request: IHelloRequest, options?: CallOptions): Promise<IHelloResponse> {
    return await this.channel.startUnary(request, this.getContext(), GreeterClient.sayHelloMethodInfo, options);
  }
  private static readonly sayHelloClientMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloClient',
    service: 'GreeterService',
    id: 3429833156,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    toJSON: HelloRequest.encodeToJSON,
    fromJSON: HelloResponse.fromJSON,
    type: MethodType.ClientStream,
  }

  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<IHelloResponse>;
  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options: CallOptions): Promise<IHelloResponse>;
  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options?: CallOptions): Promise<IHelloResponse> {
    return await this.channel.startClientStream(request, this.getContext(), GreeterClient.sayHelloClientMethodInfo, options);
  }
  private static readonly sayHelloServerMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloServer',
    service: 'GreeterService',
    id: 3393365588,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    toJSON: HelloRequest.encodeToJSON,
    fromJSON: HelloResponse.fromJSON,
    type: MethodType.ServerStream,
  }

  async sayHelloServer(request: IHelloRequest): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloServer(request: IHelloRequest, options: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloServer(request: IHelloRequest, options?: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>> {
    return await this.channel.startServerStream(request, this.getContext(), GreeterClient.sayHelloServerMethodInfo, options);
  }
  private static readonly sayHelloDuplexMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloDuplex',
    service: 'GreeterService',
    id: 2551291458,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    toJSON: HelloRequest.encodeToJSON,
    fromJSON: HelloResponse.fromJSON,
    type: MethodType.DuplexStream,
  }

  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options?: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>> {
    return await this.channel.startDuplexStream(request, this.getContext(), GreeterClient.sayHelloDuplexMethodInfo, options);
  }
}
