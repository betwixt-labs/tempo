//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.6.2
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord } from "bebop";
import { Metadata, MethodType } from "@tempojs/common";
import {  BaseClient, MethodInfo, CallOptions } from "@tempojs/client";
import { ServiceRegistry, BaseService, ServerContext, BebopMethodAny, BebopMethod } from "@tempojs/server";

/**
 * `HelloRequest` is a struct representing a request to the Greeter service.
 */
export interface IHelloRequest extends BebopRecord {
  /**
   * The name to be used in the greeting, of type string.
   */
  name: string;
}

export class HelloRequest implements IHelloRequest {
  public name: string;

  constructor(record: IHelloRequest) {
    this.name = record.name;
  }

  public encode(): Uint8Array {
    return HelloRequest.encode(this);
  }

  public static encode(record: IHelloRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloRequest, view: BebopView): number {
    const before = view.length;
    view.writeString(record.name);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloRequest {
    let field0: string;
    field0 = view.readString();
    let message: IHelloRequest = {
      name: field0,
    };
    return new this(message);
  }
}

/**
 * `HelloResponse` is a struct representing the response from the Greeter service.
 */
export interface IHelloResponse extends BebopRecord {
  /**
   * The greeting message generated by the service, of type string.
   */
  serviceMessage: string;
}

export class HelloResponse implements IHelloResponse {
  public serviceMessage: string;

  constructor(record: IHelloResponse) {
    this.serviceMessage = record.serviceMessage;
  }

  public encode(): Uint8Array {
    return HelloResponse.encode(this);
  }

  public static encode(record: IHelloResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloResponse, view: BebopView): number {
    const before = view.length;
    view.writeString(record.serviceMessage);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloResponse {
    let field0: string;
    field0 = view.readString();
    let message: IHelloResponse = {
      serviceMessage: field0,
    };
    return new this(message);
  }
}

/**
 * `Greeter` is a service that provides a method for generating greeting messages.
 */
export abstract class BaseGreeterService extends BaseService {
  public static readonly serviceName = 'GreeterService';
  public abstract sayHello(record: IHelloRequest, context: ServerContext): Promise<IHelloResponse>;
  public abstract sayHelloClient(records: () => AsyncGenerator<IHelloRequest, void, undefined>, context: ServerContext): Promise<IHelloResponse>;
  public abstract sayHelloServer(record: IHelloRequest, context: ServerContext): AsyncGenerator<IHelloResponse, void, undefined>;
  public abstract sayHelloDuplex(records: () => AsyncGenerator<IHelloRequest, void, undefined>, context: ServerContext): AsyncGenerator<IHelloResponse, void, undefined>;
}

export class TempoServiceRegistry extends ServiceRegistry {
  private static readonly staticServiceInstances: Map<string, BaseService> = new Map<string, BaseService>();
  public static register(serviceName: string) {
    return (constructor: Function) => {
      const service = Reflect.construct(constructor, [undefined]);
      if (TempoServiceRegistry.staticServiceInstances.has(serviceName)) {
        throw new Error(`Duplicate service registered: ${serviceName}`);
      }
      TempoServiceRegistry.staticServiceInstances.set(serviceName, service);
    }
  }
  public static tryGetService(serviceName: string): BaseService {
    const service = TempoServiceRegistry.staticServiceInstances.get(serviceName);
    if (service === undefined) {
      throw new Error(`Unable to retreive service '${serviceName}' - it is not registered.`);
    }
    return service;
  }

  public init(): void {
    let service: BaseService;
    let serviceName: string;
    serviceName = 'GreeterService';
    service = TempoServiceRegistry.tryGetService(serviceName);
    if (!(service instanceof BaseGreeterService)) {
      throw new Error('todo');
    }
    service.setLogger(this.logger.clone(serviceName));
    TempoServiceRegistry.staticServiceInstances.delete(serviceName);
    this.serviceInstances.push(service);
    if (this.methods.has(1225452181)) {
      const conflictService = this.methods.get(1225452181)!;
      throw new Error(`GreeterService.sayHello collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(1225452181, {
      name: 'sayHello',
      service: serviceName,
      invoke: service.sayHello,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      type: MethodType.Unary,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(3391540084)) {
      const conflictService = this.methods.get(3391540084)!;
      throw new Error(`GreeterService.sayHelloClient collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(3391540084, {
      name: 'sayHelloClient',
      service: serviceName,
      invoke: service.sayHelloClient,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      type: MethodType.ClientStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(838180561)) {
      const conflictService = this.methods.get(838180561)!;
      throw new Error(`GreeterService.sayHelloServer collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(838180561, {
      name: 'sayHelloServer',
      service: serviceName,
      invoke: service.sayHelloServer,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      type: MethodType.ServerStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
    if (this.methods.has(2725697664)) {
      const conflictService = this.methods.get(2725697664)!;
      throw new Error(`GreeterService.sayHelloDuplex collides with ${conflictService.service}.${conflictService.name}`)
    }
    this.methods.set(2725697664, {
      name: 'sayHelloDuplex',
      service: serviceName,
      invoke: service.sayHelloDuplex,
      serialize: HelloResponse.encode,
      deserialize: HelloRequest.decode,
      type: MethodType.DuplexStream,
    } as BebopMethod<IHelloRequest, IHelloResponse>);
  }

  getMethod(id: number): BebopMethodAny | undefined {
    return this.methods.get(id);
  }
}
export interface IGreeterClient {
  sayHello(request: IHelloRequest): Promise<IHelloResponse>;
  sayHello(request: IHelloRequest, metadata: Metadata): Promise<IHelloResponse>;
  sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<IHelloResponse>;
  sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, metadata: Metadata): Promise<IHelloResponse>;
  sayHelloServer(request: IHelloRequest): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  sayHelloServer(request: IHelloRequest, metadata: Metadata): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, metadata: Metadata): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
}

export class GreeterClient extends BaseClient implements IGreeterClient {
  private static readonly sayHelloMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHello',
    service: 'GreeterService',
    id: 1225452181,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    type: MethodType.Unary,
  }
  async sayHello(request: IHelloRequest): Promise<IHelloResponse>;
  async sayHello(request: IHelloRequest, options: CallOptions): Promise<IHelloResponse>;
  async sayHello(request: IHelloRequest, options?: CallOptions): Promise<IHelloResponse> {
    return await this.channel.startUnary(request, this.getContext(), GreeterClient.sayHelloMethodInfo, options);
  }
  private static readonly sayHelloClientMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloClient',
    service: 'GreeterService',
    id: 3391540084,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    type: MethodType.ClientStream,
  }
  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<IHelloResponse>;
  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options: CallOptions): Promise<IHelloResponse>;
  async sayHelloClient(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options?: CallOptions): Promise<IHelloResponse> {
    return await this.channel.startClientStream(request, this.getContext(), GreeterClient.sayHelloClientMethodInfo, options);
  }
  private static readonly sayHelloServerMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloServer',
    service: 'GreeterService',
    id: 838180561,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    type: MethodType.ServerStream,
  }
  async sayHelloServer(request: IHelloRequest): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloServer(request: IHelloRequest, options: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloServer(request: IHelloRequest, options?: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>> {
    return await this.channel.startServerStream(request, this.getContext(), GreeterClient.sayHelloServerMethodInfo, options);
  }
  private static readonly sayHelloDuplexMethodInfo: MethodInfo<IHelloRequest, IHelloResponse> = {
    name: 'sayHelloDuplex',
    service: 'GreeterService',
    id: 2725697664,
    serialize: HelloRequest.encode,
    deserialize: HelloResponse.decode,
    type: MethodType.DuplexStream,
  }
  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>>;
  async sayHelloDuplex(request: () => AsyncGenerator<IHelloRequest, void, undefined>, options?: CallOptions): Promise<AsyncGenerator<IHelloResponse, void, undefined>> {
    return await this.channel.startDuplexStream(request, this.getContext(), GreeterClient.sayHelloDuplexMethodInfo, options);
  }
}
